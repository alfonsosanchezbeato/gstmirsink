From e72dd53491eaeddc813b8e70d05a39885508d404 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Alfonso=20S=C3=A1nchez-Beato?=
 <alfonsosanchezbeato@yahoo.es>
Date: Thu, 23 Feb 2017 15:22:35 +0100
Subject: [PATCH] mirsink to use with Mir server

The mirsink works in two modes: if "export-buffers" property is set, it
exports dma buffers that are sent to the application by posting a
GstMessage. If not, it creates its own rendering Mir window.
---
 configure.ac         |   13 +
 ext/Makefile.am      |    8 +
 ext/mir/Makefile.am  |   14 +
 ext/mir/gstmirsink.c | 1060 ++++++++++++++++++++++++++++++++++++++++++++++++++
 ext/mir/gstmirsink.h |  186 +++++++++
 5 files changed, 1281 insertions(+)
 create mode 100644 ext/mir/Makefile.am
 create mode 100644 ext/mir/gstmirsink.c
 create mode 100644 ext/mir/gstmirsink.h

diff --git a/configure.ac b/configure.ac
index 10b850d..f803c30 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1736,6 +1736,17 @@ AG_GST_CHECK_FEATURE(ANDROID_MEDIA, [Android Media], androidmedia, [
   esac
 ])
 
+dnl *** A mir-based Platform ***
+translit(dnm, m, l) AM_CONDITIONAL(USE_MIR, true)
+HAVE_MIR="no"
+dnl Check for the presence of Mir client library
+AG_GST_CHECK_FEATURE(MIR, [Mir Server], mir, [
+      PKG_CHECK_MODULES(MIR, mirclient,
+              [HAVE_MIR="yes"],
+              [HAVE_MIR="no"]
+      )
+])
+
 dnl *** AppleMedia (OS X and iOS) ***
 translit(dnm, m, l) AM_CONDITIONAL(USE_APPLE_MEDIA, true)
 HAVE_APPLE_MEDIA="no"
@@ -3300,6 +3311,7 @@ AM_CONDITIONAL(DECKLINK_OSX, false)
 AM_CONDITIONAL(USE_DIRECTFB, false)
 AM_CONDITIONAL(USE_WAYLAND, false)
 AM_CONDITIONAL(USE_DAALA, false)
+AM_CONDITIONAL(USE_MIR, false)
 AM_CONDITIONAL(USE_DTS, false)
 AM_CONDITIONAL(USE_EXIF, false)
 AM_CONDITIONAL(USE_RESINDVD, false)
@@ -3617,6 +3629,7 @@ ext/lv2/Makefile
 ext/libde265/Makefile
 ext/libmms/Makefile
 ext/Makefile
+ext/mir/Makefile
 ext/modplug/Makefile
 ext/mpeg2enc/Makefile
 ext/mplex/Makefile
diff --git a/ext/Makefile.am b/ext/Makefile.am
index 534b9ac..2314e9d 100644
--- a/ext/Makefile.am
+++ b/ext/Makefile.am
@@ -64,6 +64,12 @@ else
 DAALA_DIR=
 endif
 
+if USE_MIR
+MIR_DIR=mir
+else
+MIR_DIR=
+endif
+
 if USE_DTS
 DTS_DIR=dts
 else
@@ -420,6 +426,7 @@ SUBDIRS=\
 	$(LV2_DIR) \
 	$(LIBDE265_DIR) \
 	$(LIBMMS_DIR) \
+	$(MIR_DIR) \
 	$(MODPLUG_DIR) \
 	$(MPEG2ENC_DIR) \
 	$(MPLEX_DIR) \
@@ -484,6 +491,7 @@ DIST_SUBDIRS = \
 	gl \
 	gtk \
 	qt \
+	mir \
 	modplug \
 	mpeg2enc \
 	mplex \
diff --git a/ext/mir/Makefile.am b/ext/mir/Makefile.am
new file mode 100644
index 0000000..c691e7a
--- /dev/null
+++ b/ext/mir/Makefile.am
@@ -0,0 +1,14 @@
+plugin_LTLIBRARIES = libgstmirsink.la
+
+libgstmirsink_la_SOURCES = gstmirsink.c
+libgstmirsink_la_CFLAGS = $(GST_CFLAGS) $(GST_BASE_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) \
+                               $(MIR_CFLAGS) \
+                               -I../../gst-libs/
+libgstmirsink_la_LIBADD = $(GST_PLUGINS_BASE_LIBS) $(GST_BASE_LIBS) $(GST_LIBS) \
+                               -lgstvideo-$(GST_API_VERSION) \
+                               $(GL_LIBS) $(EGL_LIBS) $(EGLGLES_LIBS) \
+                               $(MIR_LIBS)
+libgstmirsink_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+libgstmirsink_la_LIBTOOLFLAGS = $(GST_PLUGIN_LIBTOOLFLAGS)
+include_HEADERS = gstmirsink.h
+noinst_HEADERS =
diff --git a/ext/mir/gstmirsink.c b/ext/mir/gstmirsink.c
new file mode 100644
index 0000000..db32669
--- /dev/null
+++ b/ext/mir/gstmirsink.c
@@ -0,0 +1,1060 @@
+/*
+ * GStreamer Mir video sink
+ * Copyright (C) 2017 Canonical Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ */
+
+/**
+ * SECTION:element-mirsink
+ *
+ *  The mirsink works in two modes: if "export-buffers" property is set, it
+ *  exports dma buffers that are sent to the client by posting a GstMessage.
+ *  If not, it creates its own rendering window.
+ *  TODO: a third mode where the rendering surface is provided by the client.
+ *
+ * <refsect2>
+ * <title>Example pipeline</title>
+ * |[
+ * gst-launch-1.0 filesrc location=<video_file> ! qtdemux ! queue ! \
+ *                h264parse ! avdec_h264 ! mirsink
+ * ]| test the video rendering with mirsink
+ * </refsect2>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "gstmirsink.h"
+
+#define POOL_MIN_NUM_BUFF 2
+/* Means unlimited */
+#define POOL_MAX_NUM_BUFF 0
+
+/* Properties */
+enum
+{
+  PROP_0,
+  PROP_MIR_EXPORT_BUFFERS
+};
+
+GST_DEBUG_CATEGORY (gstmir_debug);
+#define GST_CAT_DEFAULT gstmir_debug
+
+static GstStaticPadTemplate gst_mirsink_sink_caps_template =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (GST_VIDEO_CAPS_MAKE
+        ("{ BGRx, BGRA, RGBx, xBGR, xRGB, RGBA, ABGR, ARGB, RGB, BGR, "
+            "RGB16, BGR16, YUY2, YVYU, UYVY, AYUV, NV12, NV21, NV16, "
+            "YUV9, YVU9, Y41B, I420, YV12, Y42B, v308 }"))
+    );
+
+#define gst_mir_sink_parent_class parent_class
+G_DEFINE_TYPE (GstMirSink, gst_mir_sink, GST_TYPE_VIDEO_SINK);
+
+static void gst_mir_sink_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec);
+static void gst_mir_sink_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec);
+static void gst_mir_sink_finalize (GObject * object);
+static void gst_mir_sink_set_context (GstElement * element,
+    GstContext * context);
+static gboolean gst_mir_sink_set_caps (GstBaseSink * bsink, GstCaps * caps);
+static gboolean gst_mir_sink_stop (GstBaseSink * bsink);
+static gboolean gst_mir_sink_show_frame (GstVideoSink * bsink,
+    GstBuffer * buffer);
+static gboolean gst_mir_sink_propose_allocation (GstBaseSink * bsink,
+    GstQuery * query);
+static gboolean gst_mir_sink_render (GstBaseSink * bsink, GstBuffer * buffer);
+static gboolean gst_mir_sink_query (GstBaseSink * bsink, GstQuery * query);
+
+static void
+gst_mir_sink_class_init (GstMirSinkClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *gstelement_class;
+  GstBaseSinkClass *gstbasesink_class;
+  GstVideoSinkClass *gstvideosink_class;
+
+  gobject_class = (GObjectClass *) klass;
+  gstelement_class = (GstElementClass *) klass;
+  gstbasesink_class = (GstBaseSinkClass *) klass;
+  gstvideosink_class = (GstVideoSinkClass *) klass;
+
+  gobject_class->set_property = gst_mir_sink_set_property;
+  gobject_class->get_property = gst_mir_sink_get_property;
+  gobject_class->finalize = GST_DEBUG_FUNCPTR (gst_mir_sink_finalize);
+
+  gst_element_class_add_static_pad_template (gstelement_class,
+      &gst_mirsink_sink_caps_template);
+
+  gst_element_class_set_static_metadata (gstelement_class,
+      "Mir video sink", "Sink/Video",
+      "Output to Mir surface",
+      "Alfonso Sanchez-Beato <alfonso.sanchez-beato@canonical.com>");
+
+  gstelement_class->set_context = GST_DEBUG_FUNCPTR (gst_mir_sink_set_context);
+
+  gstbasesink_class->set_caps = GST_DEBUG_FUNCPTR (gst_mir_sink_set_caps);
+  gstbasesink_class->stop = GST_DEBUG_FUNCPTR (gst_mir_sink_stop);
+  gstbasesink_class->propose_allocation =
+      GST_DEBUG_FUNCPTR (gst_mir_sink_propose_allocation);
+  gstbasesink_class->render = GST_DEBUG_FUNCPTR (gst_mir_sink_render);
+  gstbasesink_class->query = GST_DEBUG_FUNCPTR (gst_mir_sink_query);
+
+  gstvideosink_class->show_frame = GST_DEBUG_FUNCPTR (gst_mir_sink_show_frame);
+
+  g_object_class_install_property (gobject_class, PROP_MIR_EXPORT_BUFFERS,
+      g_param_spec_boolean (GST_MIRSINK_PROP_EXPORT_BUFFERS,
+          "Export buffers flag",
+          "If set, dma_buf fds with decoded video are exported", FALSE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+}
+
+static void
+gst_mir_sink_init (GstMirSink * sink)
+{
+  GST_DEBUG_OBJECT (sink, "Initializing mirsink");
+  sink->pool = NULL;
+
+  sink->export_buffers = FALSE;
+
+  g_mutex_init (&sink->mir_lock);
+}
+
+static void
+gst_mir_sink_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec)
+{
+  GstMirSink *sink = GST_MIR_SINK (object);
+
+  switch (prop_id) {
+    case PROP_MIR_EXPORT_BUFFERS:
+      g_value_set_boolean (value, sink->export_buffers);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_mir_sink_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec)
+{
+  GstMirSink *sink = GST_MIR_SINK (object);
+
+  switch (prop_id) {
+    case PROP_MIR_EXPORT_BUFFERS:
+      sink->export_buffers = g_value_get_boolean (value);
+      GST_INFO_OBJECT (object, "export_buffers set: %d", sink->export_buffers);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_mir_sink_finalize (GObject * object)
+{
+  GstMirSink *sink = GST_MIR_SINK (object);
+
+  GST_DEBUG_OBJECT (sink, "Finalizing the sink..");
+
+  g_mutex_clear (&sink->mir_lock);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gst_mir_sink_set_context (GstElement * element, GstContext * context)
+{
+  /* TODO Will handle reception of mir rendering window */
+  GST_INFO_OBJECT (element, "%s", __PRETTY_FUNCTION__);
+}
+
+static gboolean
+gst_mir_sink_query (GstBaseSink * bsink, GstQuery * query)
+{
+  GstMirSink *sink = GST_MIR_SINK (bsink);
+
+  GST_INFO_OBJECT (sink, "query type %s", GST_QUERY_TYPE_NAME (query));
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_CONTEXT:
+    default:
+      goto base_class;
+      break;
+  }
+
+base_class:
+  return GST_BASE_SINK_CLASS (parent_class)->query (bsink, query);
+}
+
+static GstBufferPool *
+gst_mir_sink_create_pool (GstMirSink * sink, GstCaps * caps)
+{
+  GstBufferPool *pool;
+  GstStructure *structure;
+  gsize size = sink->video_info.size;
+
+  pool = gst_video_buffer_pool_new ();
+
+  structure = gst_buffer_pool_get_config (pool);
+  gst_buffer_pool_config_set_params (structure, caps, size,
+      POOL_MIN_NUM_BUFF, POOL_MAX_NUM_BUFF);
+  gst_buffer_pool_config_set_allocator (structure, gst_allocator_find (NULL),
+      NULL);
+
+  if (!gst_buffer_pool_set_config (pool, structure)) {
+    g_object_unref (pool);
+    pool = NULL;
+  }
+
+  return pool;
+}
+
+static gboolean
+gst_mir_sink_set_caps (GstBaseSink * bsink, GstCaps * caps)
+{
+  GstMirSink *sink = GST_MIR_SINK (bsink);
+  GstBufferPool *newpool;
+
+  sink = GST_MIR_SINK (bsink);
+
+  GST_DEBUG_OBJECT (sink, "set caps %" GST_PTR_FORMAT, caps);
+
+  if (!gst_video_info_from_caps (&sink->video_info, caps))
+    goto invalid_format;
+
+  GST_DEBUG_OBJECT (sink, "width: %u", sink->video_info.width);
+  GST_DEBUG_OBJECT (sink, "height: %u", sink->video_info.height);
+  GST_DEBUG_OBJECT (sink, "Format %s (%s, %d)",
+      (sink->video_info.finfo)->description,
+      (sink->video_info.finfo)->name, (sink->video_info.finfo)->format);
+  GST_DEBUG_OBJECT (sink, "Default allocator at 0x%p",
+      gst_allocator_find (NULL));
+
+  /* Create a new pool for the new configuration */
+  GST_DEBUG_OBJECT (sink, "Creating new GstBufferPool");
+
+  newpool = gst_mir_sink_create_pool (sink, caps);
+  if (!newpool)
+    goto pool_failed;
+
+  gst_object_replace ((GstObject **) & sink->pool, (GstObject *) newpool);
+  gst_object_unref (newpool);
+
+  GST_DEBUG_OBJECT (sink, "Finishing up set_caps");
+
+  return TRUE;
+
+invalid_format:
+  {
+    GST_DEBUG_OBJECT (sink,
+        "Could not locate image format from caps %" GST_PTR_FORMAT, caps);
+    return FALSE;
+  }
+pool_failed:
+  {
+    GST_DEBUG_OBJECT (sink, "Failed to create new pool");
+    return FALSE;
+  }
+}
+
+/* vertex shader */
+static const char vshadersrc[] =
+    "attribute vec4 attrpos;\n"
+    "attribute vec2 attrcordY;\n"
+    "attribute vec2 attrcordU;\n"
+    "attribute vec2 attrcordV;\n"
+    "varying vec2 cordY;\n"
+    "varying vec2 cordU;\n"
+    "varying vec2 cordV;\n"
+    "\n"
+    "void main ()\n"
+    "{\n"
+    "  cordY = attrcordY;\n"
+    "  cordU = attrcordU;\n"
+    "  cordV = attrcordV;\n" "  gl_Position = attrpos;\n" "}\n";
+
+/* fragment shader */
+static const char fshadersrc[] =
+    "precision mediump float;\n"
+    "uniform sampler2D sampY;\n"
+    "uniform sampler2D sampU;\n"
+    "uniform sampler2D sampV;\n"
+    "uniform mat4 yuvmat;\n"
+    "varying vec2 cordY;\n"
+    "varying vec2 cordU;\n"
+    "varying vec2 cordV;\n"
+    "\n"
+    "/* Convert YV12 to RGB */\n"
+    "void main()\n"
+    "{\n"
+    "  vec4 yuv, rgb;\n"
+    "\n"
+    "  yuv.rgba = vec4(texture2D(sampY, cordY).r,\n"
+    "                  texture2D(sampU, cordU).r - 0.5,\n"
+    "                  texture2D(sampV, cordV).r - 0.5,\n"
+    "                  1.0);\n"
+    "\n" "  rgb = yuvmat * yuv;\n" "  gl_FragColor = rgb;\n" "}\n";
+
+/* YUV to RGB conversion matrix */
+static GLfloat yuv_coef_bt601[4][4] = {
+  {1.0f, 1.0f, 1.0f, 0.0f},
+  {0.0f, -0.344f, 1.773f, 0.0f},
+  {1.403f, -0.714f, 0.0f, 0.0f},
+  {0.0f, 0.0f, 0.0f, 1.0f}
+};
+
+/* Set vertex coordinates to (-1,1), (1,1), (1,-1), (-1,-1), so we fill all
+ * the virtual device surface.
+ */
+static GLfloat dest_vert[4][2] =
+    { {-1.f, 1.f}, {1.f, 1.f}, {1.f, -1.f}, {-1.f, -1.f} };
+
+/* Set texture coordinates to (0,0), (1,0), (1,1), (0,1) so we cover fully the
+ * drawn surface. Note that texture coordinates have a [0,1] range.
+ */
+static GLfloat tex_vert[3][4][2] = {
+  {{0.f, 0.f}, {1.f, 0.f}, {1.f, 1.f}, {0.f, 1.f}},
+  {{0.f, 0.f}, {1.f, 0.f}, {1.f, 1.f}, {0.f, 1.f}},
+  {{0.f, 0.f}, {1.f, 0.f}, {1.f, 1.f}, {0.f, 1.f}},
+};
+
+static gboolean
+gl_error (GstMirSink * sink)
+{
+  GLenum err;
+  gboolean is_gl_err = FALSE;
+
+  while ((err = glGetError ()) != GL_NO_ERROR) {
+    GST_ERROR_OBJECT (sink, "OpenGL error %d (0x%X)", err, err);
+    is_gl_err = TRUE;
+  }
+
+  return is_gl_err;
+}
+
+static GLuint
+load_shader (GstMirSink * sink, const char *src, GLenum type)
+{
+  GLuint shader = glCreateShader (type);
+  GLint compiled;
+
+  if (!shader)
+    goto exit;
+
+  glShaderSource (shader, 1, &src, NULL);
+  glCompileShader (shader);
+  glGetShaderiv (shader, GL_COMPILE_STATUS, &compiled);
+
+  if (!compiled) {
+    GLchar log[1024];
+
+    glGetShaderInfoLog (shader, sizeof log - 1, NULL, log);
+    log[sizeof log - 1] = '\0';
+    GST_ERROR_OBJECT (sink, "load_shader compile failed: %s", log);
+    glDeleteShader (shader);
+    shader = 0;
+  }
+
+exit:
+  return shader;
+}
+
+static gboolean
+create_shaders (GstMirSink * sink)
+{
+  GLint linked;
+  int i;
+
+  sink->vshader = load_shader (sink, vshadersrc, GL_VERTEX_SHADER);
+  if (!sink->vshader) {
+    GST_ERROR_OBJECT (sink, "Cannot create vertex shader for mirsink");
+    goto error;
+  }
+  sink->fshader = load_shader (sink, fshadersrc, GL_FRAGMENT_SHADER);
+  if (!sink->fshader) {
+    GST_ERROR_OBJECT (sink, "Cannot create fragment shader for mirsink");
+    goto error;
+  }
+  sink->prog = glCreateProgram ();
+  if (!sink->prog) {
+    GST_ERROR_OBJECT (sink, "Cannot create GLSL program");
+    goto error;
+  }
+  glAttachShader (sink->prog, sink->vshader);
+  glAttachShader (sink->prog, sink->fshader);
+  glLinkProgram (sink->prog);
+
+  glGetProgramiv (sink->prog, GL_LINK_STATUS, &linked);
+  if (!linked) {
+    GLchar log[1024];
+    glGetProgramInfoLog (sink->prog, sizeof log - 1, NULL, log);
+    log[sizeof log - 1] = '\0';
+    GST_ERROR_OBJECT (sink, "Link failed: %s", log);
+    goto error;
+  }
+
+  glUseProgram (sink->prog);
+
+  sink->attrpos = glGetAttribLocation (sink->prog, "attrpos");
+  sink->attrcordYUV[0] = glGetAttribLocation (sink->prog, "attrcordY");
+  sink->attrcordYUV[1] = glGetAttribLocation (sink->prog, "attrcordU");
+  sink->attrcordYUV[2] = glGetAttribLocation (sink->prog, "attrcordV");
+  sink->sampYUV[0] = glGetUniformLocation (sink->prog, "sampY");
+  sink->sampYUV[1] = glGetUniformLocation (sink->prog, "sampU");
+  sink->sampYUV[2] = glGetUniformLocation (sink->prog, "sampV");
+  sink->yuvmat = glGetUniformLocation (sink->prog, "yuvmat");
+
+  /* Set shader variables */
+
+  glUniformMatrix4fv (sink->yuvmat, 1, GL_FALSE, &yuv_coef_bt601[0][0]);
+
+  /* Missing components filled by specification with (0,0,0,1) */
+  glVertexAttribPointer (sink->attrpos, 2, GL_FLOAT, GL_FALSE, 0, dest_vert);
+  glEnableVertexAttribArray (sink->attrpos);
+
+  for (i = 0; i < G_N_ELEMENTS (sink->attrcordYUV); ++i) {
+    glVertexAttribPointer (sink->attrcordYUV[i], 2, GL_FLOAT,
+        GL_FALSE, 0, tex_vert[i]);
+    glEnableVertexAttribArray (sink->attrcordYUV[i]);
+  }
+
+  /* Create textures for YUV planes */
+  glGenTextures (G_N_ELEMENTS (sink->text_id), sink->text_id);
+
+  for (i = 0; i < G_N_ELEMENTS (sink->attrcordYUV); ++i) {
+    /* GL_TEXTUREi = GL_TEXTURE0 + i is guaranteed */
+    /* Looks like OGLES selects the first free texture anyway, so calling
+     * glActiveTexture here is not a must. But it is needed when rendering. */
+    glActiveTexture (GL_TEXTURE0 + i);
+    glBindTexture (GL_TEXTURE_2D, sink->text_id[i]);
+    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+    glUniform1i (sink->sampYUV[i], i);
+  }
+
+  if (gl_error (sink))
+    goto error;
+
+  return TRUE;
+
+error:
+  glDeleteTextures (G_N_ELEMENTS (sink->text_id), sink->text_id);
+  /* So we know they do not exist anymore */
+  memset (sink->text_id, 0, sizeof sink->text_id);
+
+  glDisableVertexAttribArray (sink->attrpos);
+  sink->attrpos = 0;
+  for (i = 0; i < G_N_ELEMENTS (sink->attrcordYUV); ++i)
+    glDisableVertexAttribArray (sink->attrcordYUV[i]);
+  /* So we know they do not exist anymore */
+  memset (sink->attrcordYUV, 0, sizeof sink->attrcordYUV);
+
+  glDeleteShader (sink->vshader);
+  glDeleteShader (sink->fshader);
+  glDeleteProgram (sink->prog);
+  sink->vshader = 0;
+  sink->fshader = 0;
+  sink->prog = 0;
+
+  return FALSE;
+}
+
+static void
+mir_eglapp_handle_event (MirWindow * surface, MirEvent const *ev, void *ctx)
+{
+  GstMirSink *sink = ctx;
+
+  switch (mir_event_get_type (ev)) {
+    case mir_event_type_input:
+    case mir_event_type_surface:
+    case mir_event_type_resize:
+      break;
+    case mir_event_type_close_surface:
+      /* TODO Stop streaming if this happens. Handle locking. */
+      GST_DEBUG_OBJECT (sink, "Received close event from server");
+      break;
+    default:
+      break;
+  }
+}
+
+static const MirOutput *
+find_active_output (const MirDisplayConfig * conf)
+{
+  int num_outputs = mir_display_config_get_num_outputs (conf);
+  int i;
+
+  for (i = 0; i < num_outputs; ++i) {
+    MirOutput const *output = mir_display_config_get_output (conf, i);
+    MirOutputConnectionState state = mir_output_get_connection_state (output);
+
+    if (state == mir_output_connection_state_connected &&
+        mir_output_is_enabled (output))
+      return output;
+  }
+
+  return NULL;
+}
+
+static EGLSurface
+create_window (GstMirSink * sink, EGLConfig eglconfig)
+{
+  MirEGLNativeWindowType mir_window;
+  MirDisplayConfig *display_config = NULL;
+  const MirOutput *display_output;
+  const MirOutputMode *display_mode;
+  int pos_x, pos_y;
+  MirWindowSpec *spec = NULL;
+  MirPixelFormat pixel_format;
+  int width, height;
+  MirBufferStream *buff_stream;
+
+  pixel_format = mir_connection_get_egl_pixel_format (sink->conn,
+      sink->egldisplay, eglconfig);
+
+  GST_DEBUG_OBJECT (sink, "Mir chose format %d", pixel_format);
+  /* As we are opaque then it's OK to switch pixel format slightly,
+   * to enable bypass/overlays to work. Otherwise the presence of an
+   * alpha channel would prevent them from being used.
+   * It would be really nice if Mesa just gave us the right answer in
+   * the first place though. (LP: #1480755)
+   */
+  if (pixel_format == mir_pixel_format_abgr_8888)
+    pixel_format = mir_pixel_format_xbgr_8888;
+  else if (pixel_format == mir_pixel_format_argb_8888)
+    pixel_format = mir_pixel_format_xrgb_8888;
+  GST_DEBUG_OBJECT (sink, "Selected format is %d", pixel_format);
+
+  display_config = mir_connection_create_display_configuration (sink->conn);
+  display_output = find_active_output (display_config);
+  if (!display_output) {
+    GST_ERROR_OBJECT (sink, "There is no active output");
+    goto error;
+  }
+
+  display_mode = mir_output_get_current_mode (display_output);
+  if (!display_mode) {
+    GST_ERROR_OBJECT (sink, "No default mode for output");
+    goto error;
+  }
+
+  pos_x = mir_output_get_position_x (display_output);
+  pos_y = mir_output_get_position_y (display_output);
+
+  width = mir_output_mode_get_width (display_mode);
+  height = mir_output_mode_get_height (display_mode);
+
+  GST_DEBUG_OBJECT (sink, "Current active output is %dx%d %+d%+d\n",
+      width, height, pos_x, pos_y);
+
+  mir_display_config_release (display_config);
+
+  spec = mir_create_normal_window_spec (sink->conn, width, height);
+  mir_window_spec_set_pixel_format (spec, pixel_format);
+  mir_window_spec_set_name (spec, "mirsink");
+
+  sink->window = mir_create_window_sync (spec);
+  mir_window_spec_release (spec);
+
+  if (!mir_window_is_valid (sink->window)) {
+    GST_ERROR_OBJECT (sink, "Cannot create valid window");
+    goto error;
+  }
+
+  mir_window_set_event_handler (sink->window, mir_eglapp_handle_event, sink);
+
+  buff_stream = mir_window_get_buffer_stream (sink->window);
+  mir_window = mir_buffer_stream_get_egl_native_window (buff_stream);
+
+  return eglCreateWindowSurface (sink->egldisplay, eglconfig,
+      (EGLNativeWindowType) mir_window, NULL);
+
+error:
+  if (sink->window) {
+    mir_window_release_sync (sink->window);
+    sink->window = NULL;
+  }
+  if (display_config)
+    mir_display_config_release (display_config);
+
+  return EGL_NO_SURFACE;
+}
+
+static gboolean
+gst_mir_sink_stop (GstBaseSink * bsink)
+{
+  GstMirSink *sink = (GstMirSink *) bsink;
+  int i;
+
+  GST_DEBUG_OBJECT (sink, "stop");
+
+  /* Clean up GL stuff */
+
+  if (sink->buf_fd) {
+    close (sink->buf_fd);
+    sink->buf_fd = 0;
+  }
+
+  glDeleteFramebuffers (1, &sink->fbo);
+  sink->fbo = 0;
+  glDeleteTextures (1, &sink->render_tex);
+  sink->render_tex = 0;
+
+  glDeleteTextures (G_N_ELEMENTS (sink->text_id), sink->text_id);
+  memset (sink->text_id, 0, sizeof sink->text_id);
+
+  glDisableVertexAttribArray (sink->attrpos);
+  sink->attrpos = 0;
+  for (i = 0; i < G_N_ELEMENTS (sink->attrcordYUV); ++i)
+    glDisableVertexAttribArray (sink->attrcordYUV[i]);
+  memset (sink->attrcordYUV, 0, sizeof sink->attrcordYUV);
+
+  glDeleteShader (sink->vshader);
+  glDeleteShader (sink->fshader);
+  glDeleteProgram (sink->prog);
+  sink->vshader = 0;
+  sink->fshader = 0;
+  sink->prog = 0;
+
+  /* Clean up EGL stuff */
+
+  if (sink->egldisplay != EGL_NO_DISPLAY) {
+    if (sink->eglsurface != EGL_NO_SURFACE) {
+      eglDestroySurface (sink->egldisplay, sink->eglsurface);
+      sink->eglsurface = EGL_NO_SURFACE;
+    }
+    if (sink->eglctx != EGL_NO_CONTEXT) {
+      eglDestroyContext (sink->egldisplay, sink->eglctx);
+      sink->eglctx = EGL_NO_CONTEXT;
+    }
+    eglTerminate (sink->egldisplay);
+    sink->egldisplay = EGL_NO_DISPLAY;
+  }
+
+  /* Clean up Mir stuff */
+
+  if (sink->window) {
+    mir_window_release_sync (sink->window);
+    sink->window = NULL;
+  }
+  if (sink->conn) {
+    mir_connection_release (sink->conn);
+    sink->conn = NULL;
+  }
+
+  /* The pool is not re-used so must be destroyed here */
+  if (sink->pool) {
+    gst_object_unref (sink->pool);
+    sink->pool = NULL;
+  }
+
+  return TRUE;
+}
+
+static gboolean
+gst_mir_sink_propose_allocation (GstBaseSink * bsink, GstQuery * query)
+{
+  GstMirSink *sink = GST_MIR_SINK (bsink);
+  GstBufferPool *pool = NULL;
+  gboolean need_pool;
+  GstCaps *caps;
+
+  GST_DEBUG_OBJECT (sink, "Proposing ALLOCATION params");
+
+  gst_query_parse_allocation (query, &caps, &need_pool);
+
+  if (need_pool)
+    pool = gst_mir_sink_create_pool (sink, caps);
+
+  if (pool) {
+    gst_query_add_allocation_pool (query, pool, sink->video_info.size,
+        POOL_MIN_NUM_BUFF, POOL_MAX_NUM_BUFF);
+    g_object_unref (pool);
+  }
+
+  gst_query_add_allocation_param (query, gst_allocator_find (NULL), NULL);
+  /* Enable strides and offsets in buffers */
+  gst_query_add_allocation_meta (query, GST_VIDEO_META_API_TYPE, NULL);
+
+  return TRUE;
+}
+
+static GstFlowReturn
+gst_mir_sink_show_frame (GstVideoSink * vsink, GstBuffer * buffer)
+{
+  GST_DEBUG_OBJECT (vsink, "show_frame buffer %p", buffer);
+  return gst_mir_sink_render (GST_BASE_SINK (vsink), buffer);
+}
+
+static PFNEGLCREATEIMAGEKHRPROC _eglCreateImageKHR;
+static PFNEGLDESTROYIMAGEKHRPROC _eglDestroyImageKHR;
+static PFNEGLEXPORTDMABUFIMAGEQUERYMESAPROC _eglExportDMABUFImageQueryMESA;
+static PFNEGLEXPORTDMABUFIMAGEMESAPROC _eglExportDMABUFImageMESA;
+
+static gboolean
+find_extension (const char *extensions, const char *ext)
+{
+  const char *found = strstr (extensions, ext);
+  int name_len = strlen (ext);
+
+  for (; found; found = strstr (found + name_len, ext)) {
+    if (found[name_len] == ' ' || found[name_len] == '\0')
+      return TRUE;
+  }
+
+  return FALSE;
+}
+
+static gboolean
+import_egl_extensions (GstMirSink * sink)
+{
+  /* EGL_KHR_image_base: for eglCreateImageKHR/eglDestroyImageKHR
+   * EGL_MESA_image_dma_buf_export: for eglExportDMABUFImage*MESA
+   * EGL_KHR_surfaceless_context: to render without a surface
+   */
+  static const char *ext_str[] = { "EGL_KHR_image_base",
+    "EGL_MESA_image_dma_buf_export",
+    "EGL_KHR_surfaceless_context"
+  };
+  const char *extensions;
+  int i;
+
+  extensions = eglQueryString (sink->egldisplay, EGL_EXTENSIONS);
+  if (!extensions)
+    return FALSE;
+
+  for (i = 0; i < G_N_ELEMENTS (ext_str); ++i) {
+    if (!find_extension (extensions, ext_str[i])) {
+      GST_ERROR_OBJECT (sink, "EGL extension %s not found", ext_str[i]);
+      return FALSE;
+    }
+  }
+
+  _eglCreateImageKHR = (PFNEGLCREATEIMAGEKHRPROC)
+      eglGetProcAddress ("eglCreateImageKHR");
+  _eglDestroyImageKHR = (PFNEGLDESTROYIMAGEKHRPROC)
+      eglGetProcAddress ("eglDestroyImageKHR");
+  _eglExportDMABUFImageQueryMESA = (PFNEGLEXPORTDMABUFIMAGEQUERYMESAPROC)
+      eglGetProcAddress ("eglExportDMABUFImageQueryMESA");
+  _eglExportDMABUFImageMESA = (PFNEGLEXPORTDMABUFIMAGEMESAPROC)
+      eglGetProcAddress ("eglExportDMABUFImageMESA");
+
+  if (!_eglCreateImageKHR || !_eglDestroyImageKHR ||
+      !_eglExportDMABUFImageQueryMESA || !_eglExportDMABUFImageMESA) {
+    GST_ERROR_OBJECT (sink, "Cannot load EGL extensions");
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+static gboolean
+export_buffers (GstMirSink * sink)
+{
+  EGLImageKHR egl_image = EGL_NO_IMAGE_KHR;
+  EGLint image_attrs[] = {
+    EGL_GL_TEXTURE_LEVEL_KHR, 0,        /* mip map level to reference */
+    EGL_IMAGE_PRESERVED_KHR, EGL_FALSE,
+    EGL_NONE
+  };
+  EGLBoolean ok;
+  int fourcc, num_planes;
+  EGLuint64KHR modifiers;
+  EGLint stride, offset;
+
+  if (!import_egl_extensions (sink))
+    goto error;
+
+  /* Create and configure rendering texture */
+  glGenTextures (1, &sink->render_tex);
+  glActiveTexture (GL_TEXTURE3);
+  glBindTexture (GL_TEXTURE_2D, sink->render_tex);
+  glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA,
+      sink->video_info.width, sink->video_info.height, 0,
+      GL_RGBA, GL_UNSIGNED_BYTE, NULL);
+  glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+  glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+  /* Generate framebuffer object */
+  glGenFramebuffers (1, &sink->fbo);
+  /* Set as target for rendering */
+  glBindFramebuffer (GL_FRAMEBUFFER, sink->fbo);
+  glFramebufferTexture2D (GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
+      sink->render_tex, 0);
+
+  if (gl_error (sink))
+    goto error;
+
+  /* Create EGL image from rendering texture */
+
+  egl_image = _eglCreateImageKHR (sink->egldisplay, sink->eglctx,
+      EGL_GL_TEXTURE_2D_KHR,
+      (EGLClientBuffer) (long) sink->render_tex, image_attrs);
+  if (egl_image == EGL_NO_IMAGE_KHR) {
+    GST_ERROR_OBJECT (sink, "eglCreateImageKHR error 0x%x", eglGetError ());
+    goto error;
+  }
+
+  /* Now get dma_buf file descriptor and related data */
+
+  ok = _eglExportDMABUFImageQueryMESA (sink->egldisplay, egl_image,
+      &fourcc, &num_planes, &modifiers);
+  if (!ok) {
+    GST_ERROR_OBJECT (sink, "eglExportDMABUFImageQueryMESA error 0x%x",
+        eglGetError ());
+    goto error;
+  }
+
+  ok = _eglExportDMABUFImageMESA (sink->egldisplay, egl_image,
+      &sink->buf_fd, &stride, &offset);
+  if (!ok) {
+    GST_ERROR_OBJECT (sink, "eglExportDMABUFImageMESA error 0x%x",
+        eglGetError ());
+    goto error;
+  }
+
+  ok = _eglDestroyImageKHR (sink->egldisplay, egl_image);
+  if (!ok)
+    GST_ERROR_OBJECT (sink, "eglDestroyImageKHR error 0x%x", eglGetError ());
+
+  /* Post message with export data to application */
+  gst_element_post_message (GST_ELEMENT (sink),
+      gst_message_new_custom (GST_MESSAGE_ELEMENT, GST_OBJECT (sink),
+          gst_structure_new (GST_MIRSINK_BUFFER_EXPORT_DATA,
+              "fd", G_TYPE_INT, sink->buf_fd,
+              "width", G_TYPE_INT, sink->video_info.width,
+              "height", G_TYPE_INT, sink->video_info.height,
+              "fourcc", G_TYPE_INT, fourcc,
+              "stride", G_TYPE_INT, stride,
+              "offset", G_TYPE_INT, offset, NULL)));
+
+  return TRUE;
+
+error:
+  if (sink->buf_fd) {
+    close (sink->buf_fd);
+    sink->buf_fd = 0;
+  }
+
+  if (egl_image != EGL_NO_IMAGE_KHR)
+    _eglDestroyImageKHR (sink->egldisplay, egl_image);
+
+  glDeleteFramebuffers (1, &sink->fbo);
+  sink->fbo = 0;
+  glDeleteTextures (1, &sink->render_tex);
+  sink->render_tex = 0;
+
+  return FALSE;
+}
+
+static gboolean
+init_renderer (GstMirSink * sink)
+{
+  EGLBoolean ok;
+  EGLConfig eglconfig;
+  EGLint neglconfigs;
+  const EGLint attribs[] = {
+    EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+    EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+    EGL_RED_SIZE, 8,
+    EGL_GREEN_SIZE, 8,
+    EGL_BLUE_SIZE, 8,
+    EGL_ALPHA_SIZE, 0,
+    EGL_NONE
+  };
+  EGLint ctxattribs[] = {
+    EGL_CONTEXT_CLIENT_VERSION, 2,
+    EGL_NONE
+  };
+
+  /* Use default server */
+  sink->conn = mir_connect_sync (NULL, "mirsink");
+  if (!mir_connection_is_valid (sink->conn)) {
+    GST_ERROR_OBJECT (sink, "Cannot create Mir connection");
+    goto error;
+  }
+
+  sink->egldisplay =
+      eglGetDisplay (mir_connection_get_egl_native_display (sink->conn));
+  if (sink->egldisplay == EGL_NO_DISPLAY) {
+    GST_ERROR_OBJECT (sink, "Cannot create egl display");
+    goto error;
+  }
+
+  ok = eglInitialize (sink->egldisplay, NULL, NULL);
+  if (!ok) {
+    GST_ERROR_OBJECT (sink, "Cannot initialize egl");
+    goto error;
+  }
+
+  ok = eglChooseConfig (sink->egldisplay, attribs, &eglconfig, 1, &neglconfigs);
+  if (!ok) {
+    GST_ERROR_OBJECT (sink, "Cannot configure egl");
+    goto error;
+  }
+  if (neglconfigs < 1) {
+    GST_ERROR_OBJECT (sink, "no egl config available");
+    goto error;
+  }
+
+  /* If exporting, use EGL_KHR_surfaceless_context so we can render offscreen.
+   * Otherwise, create a Mir window.
+   */
+  if (sink->export_buffers) {
+    sink->eglsurface = EGL_NO_SURFACE;
+  } else {
+    sink->eglsurface = create_window (sink, eglconfig);
+    if (sink->eglsurface == EGL_NO_SURFACE)
+      goto error;
+  }
+
+  sink->eglctx =
+      eglCreateContext (sink->egldisplay, eglconfig, EGL_NO_CONTEXT,
+      ctxattribs);
+  if (sink->eglctx == EGL_NO_CONTEXT) {
+    GST_ERROR_OBJECT (sink, "eglCreateContext failed");
+    goto error;
+  }
+  ok = eglMakeCurrent (sink->egldisplay, sink->eglsurface, sink->eglsurface,
+      sink->eglctx);
+  if (!ok) {
+    GST_ERROR_OBJECT (sink, "eglMakeCurrent failed");
+    goto error;
+  }
+
+  /* Configure shaders */
+  if (!create_shaders (sink))
+    goto error;
+
+  /* Proceed to export buffers */
+  if (sink->export_buffers)
+    if (!export_buffers (sink))
+      goto error;
+
+  return TRUE;
+
+error:
+  if (sink->egldisplay != EGL_NO_DISPLAY) {
+    if (sink->eglsurface != EGL_NO_SURFACE) {
+      eglDestroySurface (sink->egldisplay, sink->eglsurface);
+      sink->eglsurface = EGL_NO_SURFACE;
+    }
+    if (sink->eglctx != EGL_NO_CONTEXT) {
+      eglDestroyContext (sink->egldisplay, sink->eglctx);
+      sink->eglctx = EGL_NO_CONTEXT;
+    }
+    eglTerminate (sink->egldisplay);
+    sink->egldisplay = EGL_NO_DISPLAY;
+  }
+  if (sink->conn) {
+    mir_connection_release (sink->conn);
+    sink->conn = NULL;
+  }
+  return FALSE;
+}
+
+static GstFlowReturn
+gst_mir_sink_render (GstBaseSink * bsink, GstBuffer * buffer)
+{
+  GstMirSink *sink = GST_MIR_SINK (bsink);
+  GstVideoFrame frame;
+  int i;
+  /* Determines order of triangle strip */
+  GLubyte idx[4] = { 0, 1, 3, 2 };
+  EGLint width, height;
+  EGLBoolean ok;
+
+  GST_DEBUG_OBJECT (sink, "render buffer 0x%p", buffer);
+
+  /* Surface *must* be created in the rendering thread */
+  if (!sink->conn)
+    if (!init_renderer (sink))
+      return GST_FLOW_ERROR;
+
+  if (!gst_video_frame_map (&frame, &sink->video_info, buffer, GST_MAP_READ))
+    return GST_FLOW_ERROR;
+
+  /* Associate YUV planes to our textures */
+  for (i = 0; i < 3; ++i) {
+    /* GL_TEXTUREi = GL_TEXTURE0 + i is guaranteed */
+    glActiveTexture (GL_TEXTURE0 + i);
+    glPixelStorei (GL_UNPACK_ROW_LENGTH_EXT, frame.info.stride[i]);
+    glTexImage2D (GL_TEXTURE_2D, 0, GL_LUMINANCE,
+        i == 0 ? frame.info.width : frame.info.width / 2,
+        i == 0 ? frame.info.height : frame.info.height / 2,
+        0, GL_LUMINANCE, GL_UNSIGNED_BYTE,
+        GST_VIDEO_FRAME_PLANE_DATA (&frame, i));
+  }
+
+  if (sink->export_buffers) {
+    glViewport (0, 0, sink->video_info.width, sink->video_info.height);
+  } else {
+    if (eglQuerySurface (sink->egldisplay, sink->eglsurface, EGL_WIDTH, &width)
+        && eglQuerySurface (sink->egldisplay, sink->eglsurface, EGL_HEIGHT,
+            &height)) {
+      GST_DEBUG_OBJECT (sink, "Output size is %d x %d", width, height);
+      glViewport (0, 0, width, height);
+    }
+  }
+
+  /* Perform YUV -> RGB conversion by using GLSL shaders, and draw */
+  glDrawElements (GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_BYTE, idx);
+
+  /* Just print the errors */
+  gl_error (sink);
+
+  if (sink->export_buffers) {
+    /* Notify texture ready (TODO: use explicit fences when widely available) */
+    gst_element_post_message (GST_ELEMENT (sink),
+        gst_message_new_custom (GST_MESSAGE_ELEMENT, GST_OBJECT (sink),
+            gst_structure_new_empty (GST_MIRSINK_FRAME_READY)));
+  } else {
+    ok = eglSwapBuffers (sink->egldisplay, sink->eglsurface);
+    if (!ok)
+      GST_ERROR_OBJECT (sink, "eglSwapBuffers failed: %d", eglGetError ());
+  }
+
+  gst_video_frame_unmap (&frame);
+
+  return GST_FLOW_OK;
+}
+
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  GST_DEBUG_CATEGORY_INIT (gstmir_debug, "mirsink", 0, " mir video sink");
+
+  return gst_element_register (plugin, "mirsink", GST_RANK_MARGINAL,
+      GST_TYPE_MIR_SINK);
+}
+
+GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+    mirsink,
+    "Mir Video Sink", plugin_init, VERSION, "LGPL", GST_PACKAGE_NAME,
+    GST_PACKAGE_ORIGIN)
diff --git a/ext/mir/gstmirsink.h b/ext/mir/gstmirsink.h
new file mode 100644
index 0000000..f5439c2
--- /dev/null
+++ b/ext/mir/gstmirsink.h
@@ -0,0 +1,186 @@
+/*
+ * GStreamer Mir video sink
+ * Copyright (C) 2017 Canonical Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __GST_MIR_VIDEO_SINK_H__
+#define __GST_MIR_VIDEO_SINK_H__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <assert.h>
+#include <unistd.h>
+#include <stdint.h>
+
+#define GL_GLEXT_PROTOTYPES
+#define EGL_EGLEXT_PROTOTYPES
+
+#include <mir_toolkit/mir_client_library.h>
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+#include <GLES2/gl2.h>
+#include <GLES2/gl2ext.h>
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <gst/video/gstvideosink.h>
+#include <gst/video/gstvideometa.h>
+
+#define GST_TYPE_MIR_SINK \
+        (gst_mir_sink_get_type())
+#define GST_MIR_SINK(obj) \
+        (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MIR_SINK,GstMirSink))
+#define GST_MIR_SINK_CLASS(klass) \
+        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MIR_SINK,GstMirSinkClass))
+#define GST_IS_MIR_SINK(obj) \
+        (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MIR_SINK))
+#define GST_IS_MIR_SINK_CLASS(klass) \
+        (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MIR_SINK))
+#define GST_MIR_SINK_GET_CLASS(inst) \
+        (G_TYPE_INSTANCE_GET_CLASS ((inst), GST_TYPE_MIR_SINK, GstMirSinkClass))
+
+typedef struct _GstMirSink GstMirSink;
+typedef struct _GstMirSinkClass GstMirSinkClass;
+
+/**
+ * GST_MIRSINK_BUFFER_EXPORT_DATA:
+ *
+ * Name of custom GstMessage that will be posted to #GstBus to export
+ * buffer file descriptors and associated metadata. Only used when
+ * "export-buffers" is TRUE. This message contains the following fields:
+ * <itemizedlist>
+ * <listitem>
+ *   <para>
+ *   #G_TYPE_INT
+ *   <classname>&quot;fd&quot;</classname>:
+ *   File descriptor for the buffer
+ *   </para>
+ * </listitem>
+ * <listitem>
+ *   <para>
+ *   #G_TYPE_INT
+ *   <classname>&quot;width&quot;</classname>:
+ *   Buffer width
+ *   </para>
+ * </listitem>
+ * <listitem>
+ *   <para>
+ *   #G_TYPE_INT
+ *   <classname>&quot;height&quot;</classname>:
+ *   Buffer height
+ *   </para>
+ * </listitem>
+ * <listitem>
+ *   <para>
+ *   #G_TYPE_INT
+ *   <classname>&quot;fourcc&quot;</classname>:
+ *   Fourcc code as defined in drm/drm_fourcc.h
+ *   </para>
+ * </listitem>
+ * <listitem>
+ *   <para>
+ *   #G_TYPE_INT
+ *   <classname>&quot;stride&quot;</classname>:
+ *   Stride in bytes
+ *   </para>
+ * </listitem>
+ * <listitem>
+ *   <para>
+ *   #G_TYPE_INT
+ *   <classname>&quot;offset&quot;</classname>:
+ *   Offset for data start
+ *   </para>
+ * </listitem>
+ * </itemizedlist>
+ */
+#define GST_MIRSINK_BUFFER_EXPORT_DATA "buffer-export-data"
+
+/**
+ * GST_MIRSINK_FRAME_READY:
+ *
+ * Name of custom GstMessage that will be posted to #GstBus to signal
+ * when a new frame is ready. This message has no parameters. Only used
+ * if "export-buffers" is TRUE.
+ */
+#define GST_MIRSINK_FRAME_READY "frame-ready"
+
+/**
+ * GST_MIRSINK_PROP_EXPORT_BUFFERS:
+ *
+ * This property controls whether we want to export buffers or create
+ * locally a Mir window. Set to FALSE by default so things work as
+ * expected with gst-launch.
+ */
+#define GST_MIRSINK_PROP_EXPORT_BUFFERS "export-buffers"
+
+struct _GstMirSink
+{
+  GstVideoSink parent;
+
+  GstBufferPool *pool;
+
+  GMutex mir_lock;
+
+  /* Whether to export buffers or render them in a local window */
+  gboolean export_buffers;
+  GstVideoInfo video_info;
+
+  MirConnection *conn;
+  MirWindow *window;
+
+  EGLDisplay egldisplay;
+  EGLSurface eglsurface;
+  EGLContext eglctx;
+
+  GLuint vshader, fshader;
+
+  /* Indexes to shader variables */
+  GLint attrpos;
+  GLint attrcordYUV[3];
+  GLint sampYUV[3];
+  GLint yuvmat;
+
+  GLuint text_id[3];
+
+  GLuint prog;
+
+  /* Framebuffer object */
+  GLuint fbo;
+  GLuint render_tex;
+
+  int buf_fd;
+};
+
+struct _GstMirSinkClass
+{
+  GstVideoSinkClass parent;
+};
+
+GType gst_mir_sink_get_type (void) G_GNUC_CONST;
+
+G_END_DECLS
+
+#endif /* __GST_MIR_VIDEO_SINK_H__ */
-- 
2.9.3

